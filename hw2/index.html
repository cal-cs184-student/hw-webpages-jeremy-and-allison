<html>
<head>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<style>
	h1 {
		text-align: center;
	}

	.container {
		margin: 0 auto;
		padding: 60px 20%;
	}

	figure {
		text-align: center;
	}

	img {
		display: inline-block;
	}

	body {
		font-family: 'Inter', sans-serif;
	}
</style>
</head>
<body>
<div class="container">
<h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
<div style="text-align: center;">Names: Jeremy Fischer and Allison Dana</div>
<div style="text-align: center;"><a href="#section1">Part 1</a> - <a href="#section2">Part 2</a> - <a href="#section3">Part 3</a> - <a href="#section4">Part 4</a> - <a href="#section5">Part 5</a> - <a href="#section6">Part 6</a></div>

<br>

Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-jeremy-and-allison/hw1/index.html">https://cal-cs184-student.github.io/hw-webpages-jeremy-and-allison/hw1/index.html</a>

<br>

Link to GitHub repository:<a href="https://github.com/cal-cs184-student/sp25-hw1-jeremy-allison">https://github.com/cal-cs184-student/sp25-hw1-jeremy-allison</a>

<figure>
	<img src="teapot.png" alt="Teapot" style="width:50%"/>
	<figcaption>You can add images with captions!</figcaption>
</figure>

<!--
We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
-->

<h2>Overview</h2>
Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

<h2>Section I: Bezier Curves and Surfaces</h2>
Bezier curves are constructed with a series of linear inertpolations

<h3 id="section1">Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
Bezier curves are constructed with a series of linear interpolations (lerps) of their control points. You can imagine the control points as magnets that attract the curve, pulling it in its direction. To evaluate the control points at each step, the points are iterative over and the current point and point ahead are lerped to produce a new point. The resulting points are stored in a new array, 1 size smaller than the last. This repeats until the base case, which is when 1 point remains which is also a point on the curve.
<br><br>
<figure>
	<img src="2D bezier.png"  style="width:50%"/>
	<figcaption>Lerp Graph - Lecture 7</figcaption>
</figure>


Below is a custom curve evaluated at each step. Notice the new points created over time reduced by 1. The final point (red) is a point that lies on the curve.
<br><br>
<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
		<tr>
		<td style="text-align: center;">
			<img src="level0.png" width="400px"/>
			<figcaption>Control Points</figcaption>
		</td>
		<td style="text-align: center;">
			<img src="level1.png" width="400px"/>
			<figcaption>Level 1</figcaption>
		</td>
		<td style="text-align: center;">
			<img src="level2.png" width="400px"/>
			<figcaption>Level 2</figcaption>
		</td>
		</tr>
		<tr>
		<td style="text-align: center;">
			<img src="level3.png" width="400px"/>
			<figcaption>Level 3</figcaption>
		</td>
		<td style="text-align: center;">
			<img src="level4.png" width="400px"/>
			<figcaption>Level 4</figcaption>
		</td>
		<td style="text-align: center;">
			<img src="middle.png" width="400px"/>
			<figcaption>Final point</figcaption>
		</td>
		</tr>
	</table>
</div>

<br><br>
The <code>t</code> parameters toggles the evaluation point. Below are 3 static evaluations at different positions, and a Complimentary gif showing the smooth movement using the scroll wheel.
<br>
<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
		<tr>
		<td style="text-align: center;">
			<img src="bottom.png" width="400px"/>
			<figcaption>Parameter t Top</figcaption>
		</td>
		<td style="text-align: center;">
			<img src="finalpoint.png" width="400px"/>
			<figcaption>Parameter t Middle</figcaption>
		</td>
		<td style="text-align: center;">
			<img src="bottom.png" width="400px"/>
			<figcaption>Parameter t Bottom</figcaption>
		</td>
		</tr>
	</table>
</div>

<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
		<tr>
		<td style="text-align: center;">
			<img src="t scroll.gif" width="400px"/>
			<figcaption>Parameter t scroll (TA see website)</figcaption>
		</td>
		</tr>
	</table>
</div>

<h3 id="section2">Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
A bi-cubic Bezier surface patch has 4x4 control points, 16 total, and like the 2D case does a series of lerps to get the resulting point. First, each row of 4 points are lerped to produce 4 points. Then these points are lerped to produce the final point.

<figure>
	<img src="3D bezier.png"  style="width:50%"/>
	<figcaption>Lerp Graph 3D - Lecture 7</figcaption>
</figure>

Recursion was used in the <code>evaluate1D</code> which kept calling <code>evaluateStep</code> (which again, reduces the number of points by 1) until there was only 1 point. The overarching function <code>BezierPatch::evaluate</code> used the recursive function to evaluate the rows using scalar interpolation parameter <code>u</code> and stored them in a vector. This final vector was fed one last time into the recursive function but this time with the other axis parameter <code>v</code> to get the final point.

<br><br>
With the algorithm implemented, we could render the teapot!
<br><br>
<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
		<tr>
		<td style="text-align: center;">
			<img src="teapot.png" width="400px"/>
			<figcaption>Teapot using Bezier surfaces</figcaption>
		</td>
		</tr>
	</table>
</div>

<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

<h3 id="section3">Part 3: Area-weighted vertex normals</h3>
Given a vertex how can we get it's normal? One good idea is to get all the nearby triangle normal's and average it:

<figure>
	<img src="normal fig.png"  style="width:50%"/>
	<figcaption>Neighbor Normals - Lecture 6</figcaption>
</figure>

<figure>
	<img src="norm equation.png"  style="width:50%"/>
	<figcaption>Average Normal Equation- Lecture 6</figcaption>
</figure>
However, we want to average the weight of the area. But why? Consider if there was one neighbor triangle that was very small but had sharp normal not aligned with the other normals. This outlier would over influence the result, thus we weigh by area to dampen these outliers.

As for implementation, we loop over every triangle face, calculate its area, and multiply it by the normal. All of these area-multiplied vectors are collected and averaged to get the final result. The before and after shows the nice shading this averaging technique produces.
<br><br>
As a result, the shading makes the teapot look smooth!
<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
		<tr>
		<td style="text-align: center;">
			<img src="unshaded.png" width="400px"/>
			<figcaption>Without Averaging</figcaption>
		</td>
		<td style="text-align: center;">
			<img src="shaded.png" width="400px"/>
			<figcaption>With Averaging</figcaption>
		</td>
		</tr>
	</table>
</div>

<h3 id="section4">Part 4: Edge flip</h3>
To implement the edge flip we first defined and labeled all current elements which included the edges, faces, vertices, and half-edges. For the edge flip, we chose to flip in such a way that the flipping edge's half-edges were aligned correctly, thus we didn't need to modify edges at all. We then manually set all the half-edge references according to the labeled drawing to ensure everything got set correctly. Then, in a similar fashion, used each half-edge's <code>setNeighbors</code> to set up its references according to the new drawing correctly.

<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
		<tr>
		<td style="text-align: center;">
			<img src="TODO.png" width="400px"/>
			<figcaption>Before Flip</figcaption>
		</td>
		<td style="text-align: center;">
			<img src="TODO.png" width="400px"/>
			<figcaption>After Flip</figcaption>
		</td>
		</tr>
		<tr>
			<td style="text-align: center;">
				<img src="TODO.png" width="400px"/>
				<figcaption>Teapot Before Flips</figcaption>
			</td>
			<td style="text-align: center;">
				<img src="TODO.png" width="400px"/>
				<figcaption>Teapot After Flips</figcaption>
			</td>
		</tr>
	</table>
</div>

<h4>Notes on Debugging</h4>
We initially had an issue where flipping did work, however it would leave a hole behind periodically. This was fixed by using breakpoints and observing how each element referenced its half-edges. It was found we mismatched the 2 face's half-edge and when corrected fixed the hole issue.

<h3 id="section5">Part 5: Edge split</h3>
To implement the edge split we again drew out the before and after labeling each component. We created 1 vertex, 2 faces, 3 edges, and 6 new half-edges. Then reassigned according to the drawing and debugged with breakpoints.

<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
		<tr>
		<td style="text-align: center;">
			<img src="TODO.png" width="400px"/>
			<figcaption>Before Split</figcaption>
		</td>
		<td style="text-align: center;">
			<img src="TODO.png" width="400px"/>
			<figcaption>After Split</figcaption>
		</td>
		</tr>
		<tr>
			<td style="text-align: center;">
				<img src="TODO.png" width="400px"/>
				<figcaption>Teapot Before Splits</figcaption>
			</td>
			<td style="text-align: center;">
				<img src="TODO.png" width="400px"/>
				<figcaption>Teapot After Splits</figcaption>
			</td>
			<td style="text-align: center;">
				<img src="TODO.png" width="400px"/>
				<figcaption>Teapot After Splits & Flips</figcaption>
			</td>
		</tr>
	</table>
</div>

<h4 id="section5.1">Extra Credit: Boundary Edge split</h3>
Implementation of boundary was rather simple; only 1 vertex, 1 edge, 1 face, and 3 half-edges needed to be created. The strategies of reassignment was the same as part 4 & 5. See the result on the car model:

<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
		<tr>
		<td style="text-align: center;">
			<img src="Edge Split Before.png" width="400px"/>
			<figcaption>Before</figcaption>
		</td>
		<td style="text-align: center;">
			<img src="Edge Split After.png" width="400px"/>
			<figcaption>After</figcaption>
		</td>
		</tr>
	</table>
</div>

<h3 id="section6">Part 6: Loop subdivision for mesh upsampling</h3>

<h2>(Optional) Section III: Potential Extra Credit - Art Competition: Model something Creative</h2>

<h2>Additional Notes (please remove)</h2>


</div>
</body>
</html>