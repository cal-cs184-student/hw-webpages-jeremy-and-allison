<html>
<head>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<style>
	h1 {
		text-align: center;
	}

	.container {
		margin: 0 auto;
		padding: 60px 20%;
	}

	figure {
		text-align: center;
	}

	img {
		display: inline-block;
	}

	body {
		font-family: 'Inter', sans-serif;
	}
</style>
</head>
<body>
<div class="container">
<h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
<div style="text-align: center;">Names: Jeremy Fischer and Allison Dana</div>
<div style="text-align: center;"><a href="#section1">Part 1</a> - <a href="#section2">Part 2</a> - <a href="#section3">Part 3</a> - <a href="#section4">Part 4</a> - <a href="#section5">Part 5</a> - <a href="#section6">Part 6</a></div>

<br>

Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-jeremy-and-allison/hw1/index.html">https://cal-cs184-student.github.io/hw-webpages-jeremy-and-allison/hw1/index.html</a>

<br>

Link to GitHub repository:<a href="https://github.com/cal-cs184-student/sp25-hw1-jeremy-allison">https://github.com/cal-cs184-student/sp25-hw1-jeremy-allison</a>

<figure>
	<img src="teapot.png" alt="Teapot" style="width:50%"/>
	<figcaption>You can add images with captions!</figcaption>
</figure>

<!--
We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
-->

<h2>Overview</h2>
Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

<h2>Section I: Bezier Curves and Surfaces</h2>
Bezier curves are constructed with a series of linear inertpolations

<h3 id="section1">Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
Bezier curves are constructed with a series of linear interpolations (lerps) of their control points. You can imagine the control points as magnets that attract the curve, pulling it in its direction. To evaluate the control points at each step, the points are iterative over and the current point and point ahead are lerped to produce a new point. The resulting points are stored in a new array, 1 size smaller than the last. This repeats until the base case, which is when 1 point remains which is also a point on the curve.
<br><br>
<figure>
	<img src="2D bezier.png"  style="width:50%"/>
	<figcaption>Lerp Graph - Lecture 7</figcaption>
</figure>


Below is a custom curve evaluated at each step. Notice the new points created over time reduced by 1. The final point (red) is a point that lies on the curve.
<br><br>
<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
		<tr>
		<td style="text-align: center;">
			<img src="level0.png" width="400px"/>
			<figcaption>Control Points</figcaption>
		</td>
		<td style="text-align: center;">
			<img src="level1.png" width="400px"/>
			<figcaption>Level 1</figcaption>
		</td>
		<td style="text-align: center;">
			<img src="level2.png" width="400px"/>
			<figcaption>Level 2</figcaption>
		</td>
		</tr>
		<tr>
		<td style="text-align: center;">
			<img src="level3.png" width="400px"/>
			<figcaption>Level 3</figcaption>
		</td>
		<td style="text-align: center;">
			<img src="level4.png" width="400px"/>
			<figcaption>Level 4</figcaption>
		</td>
		<td style="text-align: center;">
			<img src="middle.png" width="400px"/>
			<figcaption>Final point</figcaption>
		</td>
		</tr>
	</table>
</div>

<br><br>
The <code>t</code> parameters toggles the evaluation point. Below are 3 static evaluations at different positions, and a Complimentary gif showing the smooth movement using the scroll wheel.
<br>
<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
		<tr>
		<td style="text-align: center;">
			<img src="bottom.png" width="400px"/>
			<figcaption>Parameter t Top</figcaption>
		</td>
		<td style="text-align: center;">
			<img src="finalpoint.png" width="400px"/>
			<figcaption>Parameter t Middle</figcaption>
		</td>
		<td style="text-align: center;">
			<img src="bottom.png" width="400px"/>
			<figcaption>Parameter t Bottom</figcaption>
		</td>
		</tr>
	</table>
</div>

<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
		<tr>
		<td style="text-align: center;">
			<img src="t scroll.gif" width="400px"/>
			<figcaption>Parameter t scroll (TA see website)</figcaption>
		</td>
		</tr>
	</table>
</div>

<h3 id="section2">Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
A bi-cubic Bezier surface patch has 4x4 control points, 16 total, and like the 2D case does a series of lerps to get the resulting point. First, each row of 4 points are lerped to produce 4 points. Then these points are lerped to produce the final point.

<figure>
	<img src="3D bezier.png"  style="width:50%"/>
	<figcaption>Lerp Graph 3D - Lecture 7</figcaption>
</figure>

Recursion was used in the <code>evaluate1D</code> which kept calling <code>evaluateStep</code> (which again, reduces the number of points by 1) until there was only 1 point. The overarching function <code>BezierPatch::evaluate</code> used the recursive function to evaluate the rows using scalar interpolation parameter <code>u</code> and stored them in a vector. This final vector was fed one last time into the recursive function but this time with the other axis parameter <code>v</code> to get the final point.

<br><br>
With the algorithm implemented, we could render the teapot!
<br><br>
<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
		<tr>
		<td style="text-align: center;">
			<img src="teapot.png" width="400px"/>
			<figcaption>Teapot using Bezier surfaces</figcaption>
		</td>
		</tr>
	</table>
</div>

<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

<h3 id="section3">Part 3: Area-weighted vertex normals</h3>


<figure>
	<img src="normal fig.png"  style="width:50%"/>
	<figcaption>Neighbor Normals - Lecture 6</figcaption>
</figure>

<figure>
	<img src="norm equation.png"  style="width:50%"/>
	<figcaption>Average - Lecture 6</figcaption>
</figure>
However, we want to average with the weight of the area. But why? Consider if there was one neighbor triangle that was very small but had sharp normal not aligned with the other normals. This outlier would unfairly affect the result, thus we weigh by area.


<h3 id="section4">Part 4: Edge flip</h3>

<h3 id="section5">Part 5: Edge split</h3>

<h3 id="section6">Part 6: Loop subdivision for mesh upsampling</h3>

<h2>(Optional) Section III: Potential Extra Credit - Art Competition: Model something Creative</h2>

<h2>Additional Notes (please remove)</h2>


</div>
</body>
</html>